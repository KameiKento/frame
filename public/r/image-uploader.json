{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "image-uploader",
  "title": "ImageUploader",
  "description": "ドラッグ&ドロップまたはクリックで複数の画像をアップロードできるコンポーネント。事前バリデーション、プレビュー表示、並び替え、進捗表示などの機能を提供します。",
  "registryDependencies": [
    "button",
    "badge"
  ],
  "files": [
    {
      "path": "src/components/image-uploader/types.ts",
      "content": "export type ImageUploadStatus = 'idle' | 'uploading' | 'success' | 'error'\n\nexport type ImageUploadError = {\n  type: 'format' | 'size' | 'count' | 'totalSize' | 'decode' | 'upload'\n  message: string\n}\n\nexport type ImageFile = {\n  id: string\n  file: File\n  previewUrl: string\n  status: ImageUploadStatus\n  error: ImageUploadError | null\n  progress: number\n  width?: number\n  height?: number\n}\n\nexport type ImageUploaderConfig = {\n  maxFiles: number\n  maxFileSize: number // bytes\n  maxTotalSize: number // bytes\n  acceptedFormats: Array<string>\n  acceptedMimeTypes: Array<string>\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/image-uploader/validation.ts",
      "content": "import type { ImageUploadError, ImageUploaderConfig } from './types'\n\nexport const defaultConfig: ImageUploaderConfig = {\n  maxFiles: 10,\n  maxFileSize: 10 * 1024 * 1024, // 10MB\n  maxTotalSize: 50 * 1024 * 1024, // 50MB\n  acceptedFormats: ['.jpg', '.jpeg', '.png', '.webp'],\n  acceptedMimeTypes: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],\n}\n\nexport function validateImageFile(\n  file: File,\n  config: ImageUploaderConfig = defaultConfig,\n): { valid: boolean; error: ImageUploadError | null } {\n  // MIME typeチェック\n  if (!config.acceptedMimeTypes.includes(file.type)) {\n    return {\n      valid: false,\n      error: {\n        type: 'format',\n        message: `対応していない形式です。許可されている形式: ${config.acceptedFormats.join(', ')}`,\n      },\n    }\n  }\n\n  // 拡張子チェック\n  const extension = file.name\n    .toLowerCase()\n    .substring(file.name.lastIndexOf('.'))\n  if (!config.acceptedFormats.includes(extension)) {\n    return {\n      valid: false,\n      error: {\n        type: 'format',\n        message: `対応していない拡張子です。許可されている拡張子: ${config.acceptedFormats.join(', ')}`,\n      },\n    }\n  }\n\n  // サイズチェック\n  if (file.size > config.maxFileSize) {\n    const maxSizeMB = (config.maxFileSize / (1024 * 1024)).toFixed(1)\n    return {\n      valid: false,\n      error: {\n        type: 'size',\n        message: `ファイルサイズが大きすぎます。最大サイズ: ${maxSizeMB}MB`,\n      },\n    }\n  }\n\n  return { valid: true, error: null }\n}\n\nexport function validateImageFiles(\n  files: Array<File>,\n  existingCount: number = 0,\n  existingTotalSize: number = 0,\n  config: ImageUploaderConfig = defaultConfig,\n): {\n  valid: boolean\n  errors: Array<{ file: File; error: ImageUploadError }>\n  validFiles: Array<File>\n} {\n  const errors: Array<{ file: File; error: ImageUploadError }> = []\n  const validFiles: Array<File> = []\n\n  // 枚数チェック\n  const totalCount = existingCount + files.length\n  if (totalCount > config.maxFiles) {\n    const excess = totalCount - config.maxFiles\n    files.forEach((file) => {\n      errors.push({\n        file,\n        error: {\n          type: 'count',\n          message: `画像の枚数が上限を超えています。最大: ${config.maxFiles}枚（あと${excess}枚削除してください）`,\n        },\n      })\n    })\n    return { valid: false, errors, validFiles }\n  }\n\n  // 合計サイズチェック\n  const newTotalSize = files.reduce((sum, file) => sum + file.size, 0)\n  const totalSize = existingTotalSize + newTotalSize\n  if (totalSize > config.maxTotalSize) {\n    const maxTotalSizeMB = (config.maxTotalSize / (1024 * 1024)).toFixed(1)\n    files.forEach((file) => {\n      errors.push({\n        file,\n        error: {\n          type: 'totalSize',\n          message: `合計サイズが上限を超えています。最大: ${maxTotalSizeMB}MB`,\n        },\n      })\n    })\n    return { valid: false, errors, validFiles }\n  }\n\n  // 個別ファイルのバリデーション\n  for (const file of files) {\n    const result = validateImageFile(file, config)\n    if (result.valid) {\n      validFiles.push(file)\n    } else {\n      errors.push({ file, error: result.error! })\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    validFiles,\n  }\n}\n\nexport async function validateImageDecode(file: File): Promise<{\n  valid: boolean\n  error: ImageUploadError | null\n  width?: number\n  height?: number\n}> {\n  return new Promise((resolve) => {\n    const img = new Image()\n    const url = URL.createObjectURL(file)\n\n    img.onload = () => {\n      URL.revokeObjectURL(url)\n      resolve({\n        valid: true,\n        error: null,\n        width: img.width,\n        height: img.height,\n      })\n    }\n\n    img.onerror = () => {\n      URL.revokeObjectURL(url)\n      resolve({\n        valid: false,\n        error: {\n          type: 'decode',\n          message: '画像ファイルが破損しているか、正しい形式ではありません',\n        },\n      })\n    }\n\n    img.src = url\n  })\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/image-uploader/utils.ts",
      "content": "import type { ImageFile } from './types'\n\nexport function generateImageId(): string {\n  return `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`\n}\n\nexport function createPreviewUrl(file: File): string {\n  return URL.createObjectURL(file)\n}\n\nexport function revokePreviewUrl(url: string): void {\n  URL.revokeObjectURL(url)\n}\n\nexport function formatFileSize(bytes: number): string {\n  if (bytes === 0) return '0 Bytes'\n  const k = 1024\n  const sizes = ['Bytes', 'KB', 'MB', 'GB']\n  const i = Math.floor(Math.log(bytes) / Math.log(k))\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`\n}\n\nexport function cleanupImageFiles(images: Array<ImageFile>): void {\n  images.forEach((image) => {\n    revokePreviewUrl(image.previewUrl)\n  })\n}\n\nexport async function mockUploadImage(\n  image: ImageFile,\n  onProgress?: (progress: number) => void,\n): Promise<{ success: boolean; error?: string }> {\n  // モックアップロード: ランダムな遅延で進捗をシミュレート\n  return new Promise((resolve) => {\n    let progress = 0\n    const interval = setInterval(() => {\n      progress += Math.random() * 30\n      if (progress >= 100) {\n        progress = 100\n        clearInterval(interval)\n        // 10%の確率でエラーをシミュレート\n        if (Math.random() < 0.1) {\n          resolve({ success: false, error: 'アップロードに失敗しました' })\n        } else {\n          resolve({ success: true })\n        }\n      } else {\n        onProgress?.(progress)\n      }\n    }, 200)\n  })\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/image-uploader/drop-zone.tsx",
      "content": "import * as React from 'react'\nimport { UploadIcon } from 'lucide-react'\nimport { cn } from '@/lib/utils'\n\ntype DropZoneProps = {\n  onFilesSelected: (files: Array<File>) => void\n  disabled?: boolean\n  className?: string\n}\n\nexport function DropZone({\n  onFilesSelected,\n  disabled = false,\n  className,\n}: DropZoneProps) {\n  const [isDragging, setIsDragging] = React.useState(false)\n  const fileInputRef = React.useRef<HTMLInputElement>(null)\n\n  const handleDragOver = React.useCallback(\n    (e: React.DragEvent<HTMLDivElement>) => {\n      e.preventDefault()\n      e.stopPropagation()\n      if (!disabled) {\n        setIsDragging(true)\n      }\n    },\n    [disabled],\n  )\n\n  const handleDragLeave = React.useCallback(\n    (e: React.DragEvent<HTMLDivElement>) => {\n      e.preventDefault()\n      e.stopPropagation()\n      setIsDragging(false)\n    },\n    [],\n  )\n\n  const handleDrop = React.useCallback(\n    (e: React.DragEvent<HTMLDivElement>) => {\n      e.preventDefault()\n      e.stopPropagation()\n      setIsDragging(false)\n\n      if (disabled) return\n\n      const files = Array.from(e.dataTransfer.files).filter((file) =>\n        file.type.startsWith('image/'),\n      )\n      if (files.length > 0) {\n        onFilesSelected(files)\n      }\n    },\n    [disabled, onFilesSelected],\n  )\n\n  const handleClick = React.useCallback(() => {\n    if (!disabled) {\n      fileInputRef.current?.click()\n    }\n  }, [disabled])\n\n  const handleFileChange = React.useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const files = Array.from(e.target.files || [])\n      if (files.length > 0) {\n        onFilesSelected(files)\n      }\n      // 同じファイルを再度選択できるようにリセット\n      if (fileInputRef.current) {\n        fileInputRef.current.value = ''\n      }\n    },\n    [onFilesSelected],\n  )\n\n  return (\n    <div\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDrop={handleDrop}\n      onClick={handleClick}\n      className={cn(\n        'relative flex flex-col items-center justify-center gap-4 rounded-lg border-2 border-dashed p-8 transition-colors',\n        isDragging\n          ? 'border-primary bg-primary/5'\n          : 'border-border bg-muted/30 hover:bg-muted/50',\n        disabled && 'pointer-events-none opacity-50',\n        className,\n      )}\n    >\n      <input\n        ref={fileInputRef}\n        type=\"file\"\n        accept=\"image/jpeg,image/jpg,image/png,image/webp\"\n        multiple\n        className=\"hidden\"\n        onChange={handleFileChange}\n        disabled={disabled}\n      />\n      <UploadIcon className=\"size-12 text-muted-foreground\" />\n      <div className=\"text-center\">\n        <p className=\"text-sm font-medium\">\n          画像をドラッグ&ドロップするか、クリックして選択\n        </p>\n        <p className=\"mt-1 text-xs text-muted-foreground\">\n          JPEG, PNG, WebP形式（最大10MB、最大10枚）\n        </p>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/image-uploader/image-preview.tsx",
      "content": "import * as React from 'react'\nimport { ChevronDownIcon, ChevronUpIcon, XIcon } from 'lucide-react'\nimport { formatFileSize } from './utils'\nimport type { ImageFile } from './types'\nimport { Button } from '@/components/ui/button'\nimport { Badge } from '@/components/ui/badge'\nimport { cn } from '@/lib/utils'\n\ntype ImagePreviewProps = {\n  image: ImageFile\n  index: number\n  total: number\n  onRemove: (id: string) => void\n  onMoveUp?: (id: string) => void\n  onMoveDown?: (id: string) => void\n  onRetry?: (id: string) => void\n}\n\nexport function ImagePreview({\n  image,\n  index,\n  total,\n  onRemove,\n  onMoveUp,\n  onMoveDown,\n  onRetry,\n}: ImagePreviewProps) {\n  const [imageError, setImageError] = React.useState(false)\n\n  const handleImageError = React.useCallback(() => {\n    setImageError(true)\n  }, [])\n\n  const statusLabel = {\n    idle: '未送信',\n    uploading: '送信中',\n    success: '成功',\n    error: 'エラー',\n  }[image.status]\n\n  const statusVariant = {\n    idle: 'outline' as const,\n    uploading: 'secondary' as const,\n    success: 'default' as const,\n    error: 'destructive' as const,\n  }[image.status]\n\n  return (\n    <div className=\"group relative overflow-hidden rounded-lg border bg-card\">\n      <div className=\"relative aspect-square w-full\">\n        {imageError ? (\n          <div className=\"flex h-full items-center justify-center bg-muted text-sm text-muted-foreground\">\n            画像の読み込みに失敗しました\n          </div>\n        ) : (\n          <img\n            src={image.previewUrl}\n            alt={image.file.name}\n            className=\"h-full w-full object-cover\"\n            onError={handleImageError}\n          />\n        )}\n        {image.status === 'uploading' && (\n          <div className=\"absolute inset-0 flex items-center justify-center bg-black/50\">\n            <div className=\"text-center text-white\">\n              <div className=\"text-sm font-medium\">\n                {Math.round(image.progress)}%\n              </div>\n              <div className=\"mt-1 h-1 w-24 overflow-hidden rounded-full bg-white/20\">\n                <div\n                  className=\"h-full bg-white transition-all\"\n                  style={{ width: `${image.progress}%` }}\n                />\n              </div>\n            </div>\n          </div>\n        )}\n        {image.status === 'error' && (\n          <div className=\"absolute inset-0 flex items-center justify-center bg-destructive/10\">\n            <div className=\"text-center\">\n              <p className=\"text-sm font-medium text-destructive\">エラー</p>\n              {onRetry && (\n                <Button\n                  size=\"sm\"\n                  variant=\"outline\"\n                  className=\"mt-2\"\n                  onClick={() => onRetry(image.id)}\n                >\n                  再試行\n                </Button>\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n      <div className=\"border-t p-2\">\n        <div className=\"mb-1 flex items-center justify-between gap-2\">\n          <p className=\"truncate text-xs font-medium\">{image.file.name}</p>\n          <Badge variant={statusVariant} className=\"shrink-0 text-xs\">\n            {statusLabel}\n          </Badge>\n        </div>\n        <div className=\"flex items-center justify-between gap-2\">\n          <p className=\"text-xs text-muted-foreground\">\n            {formatFileSize(image.file.size)}\n          </p>\n          <div className=\"flex items-center gap-1\">\n            {onMoveUp && index > 0 && (\n              <Button\n                size=\"icon-xs\"\n                variant=\"ghost\"\n                onClick={() => onMoveUp(image.id)}\n                className=\"h-5 w-5\"\n              >\n                <ChevronUpIcon className=\"size-3\" />\n              </Button>\n            )}\n            {onMoveDown && index < total - 1 && (\n              <Button\n                size=\"icon-xs\"\n                variant=\"ghost\"\n                onClick={() => onMoveDown(image.id)}\n                className=\"h-5 w-5\"\n              >\n                <ChevronDownIcon className=\"size-3\" />\n              </Button>\n            )}\n            <Button\n              size=\"icon-xs\"\n              variant=\"ghost\"\n              onClick={() => onRemove(image.id)}\n              className=\"h-5 w-5 text-destructive hover:text-destructive\"\n            >\n              <XIcon className=\"size-3\" />\n            </Button>\n          </div>\n        </div>\n        {image.error && (\n          <p className=\"mt-1 text-xs text-destructive\">{image.error.message}</p>\n        )}\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/image-uploader/image-uploader.tsx",
      "content": "import * as React from 'react'\nimport { DropZone } from './drop-zone'\nimport { ImagePreview } from './image-preview'\nimport {\n  cleanupImageFiles,\n  createPreviewUrl,\n  generateImageId,\n  mockUploadImage,\n  revokePreviewUrl,\n} from './utils'\nimport {\n  defaultConfig,\n  validateImageDecode,\n  validateImageFiles,\n} from './validation'\nimport type { ImageFile, ImageUploadError, ImageUploaderConfig } from './types'\n\ntype ImageUploaderProps = {\n  config?: Partial<ImageUploaderConfig>\n  onImagesChange?: (images: Array<ImageFile>) => void\n  autoUpload?: boolean\n  className?: string\n}\n\nexport function ImageUploader({\n  config: customConfig,\n  onImagesChange,\n  autoUpload = false,\n  className,\n}: ImageUploaderProps) {\n  const config = React.useMemo(\n    () => ({ ...defaultConfig, ...customConfig }),\n    [customConfig],\n  )\n\n  const [images, setImages] = React.useState<Array<ImageFile>>([])\n  const [errors, setErrors] = React.useState<\n    Array<{ file: File; error: ImageUploadError }>\n  >([])\n\n  // 画像変更時にコールバックを呼び出す\n  React.useEffect(() => {\n    onImagesChange?.(images)\n  }, [images, onImagesChange])\n\n  // クリーンアップ\n  React.useEffect(() => {\n    return () => {\n      cleanupImageFiles(images)\n    }\n  }, [])\n\n  const handleFilesSelected = React.useCallback(\n    async (files: Array<File>) => {\n      const existingCount = images.length\n      const existingTotalSize = images.reduce(\n        (sum, img) => sum + img.file.size,\n        0,\n      )\n\n      const validation = validateImageFiles(\n        files,\n        existingCount,\n        existingTotalSize,\n        config,\n      )\n\n      setErrors(validation.errors)\n\n      if (validation.validFiles.length === 0) {\n        return\n      }\n\n      // バリデーション済みファイルを画像オブジェクトに変換\n      const newImages: Array<ImageFile> = []\n\n      for (const file of validation.validFiles) {\n        const id = generateImageId()\n        const previewUrl = createPreviewUrl(file)\n\n        // 画像デコード検証\n        const decodeResult = await validateImageDecode(file)\n        if (!decodeResult.valid) {\n          setErrors((prev) => [...prev, { file, error: decodeResult.error! }])\n          revokePreviewUrl(previewUrl)\n          continue\n        }\n\n        const image: ImageFile = {\n          id,\n          file,\n          previewUrl,\n          status: 'idle',\n          error: null,\n          progress: 0,\n          width: decodeResult.width,\n          height: decodeResult.height,\n        }\n\n        newImages.push(image)\n      }\n\n      if (newImages.length > 0) {\n        setImages((prev) => [...prev, ...newImages])\n\n        // 自動アップロードが有効な場合\n        if (autoUpload) {\n          newImages.forEach((image) => {\n            handleUpload(image.id)\n          })\n        }\n      }\n    },\n    [images, config, autoUpload],\n  )\n\n  const handleRemove = React.useCallback((id: string) => {\n    setImages((prev) => {\n      const image = prev.find((img) => img.id === id)\n      if (image) {\n        revokePreviewUrl(image.previewUrl)\n      }\n      return prev.filter((img) => img.id !== id)\n    })\n  }, [])\n\n  const handleMoveUp = React.useCallback((id: string) => {\n    setImages((prev) => {\n      const index = prev.findIndex((img) => img.id === id)\n      if (index <= 0) return prev\n      const newImages = [...prev]\n      ;[newImages[index - 1], newImages[index]] = [\n        newImages[index],\n        newImages[index - 1],\n      ]\n      return newImages\n    })\n  }, [])\n\n  const handleMoveDown = React.useCallback((id: string) => {\n    setImages((prev) => {\n      const index = prev.findIndex((img) => img.id === id)\n      if (index < 0 || index >= prev.length - 1) return prev\n      const newImages = [...prev]\n      ;[newImages[index], newImages[index + 1]] = [\n        newImages[index + 1],\n        newImages[index],\n      ]\n      return newImages\n    })\n  }, [])\n\n  const handleUpload = React.useCallback(\n    async (id: string) => {\n      setImages((prev) =>\n        prev.map((img) =>\n          img.id === id\n            ? { ...img, status: 'uploading' as const, progress: 0, error: null }\n            : img,\n        ),\n      )\n\n      const image = images.find((img) => img.id === id)\n      if (!image) return\n\n      const result = await mockUploadImage(image, (progress) => {\n        setImages((prev) =>\n          prev.map((img) => (img.id === id ? { ...img, progress } : img)),\n        )\n      })\n\n      setImages((prev) =>\n        prev.map((img) =>\n          img.id === id\n            ? {\n                ...img,\n                status: result.success\n                  ? ('success' as const)\n                  : ('error' as const),\n                error: result.success\n                  ? null\n                  : {\n                      type: 'upload',\n                      message: result.error || 'アップロードに失敗しました',\n                    },\n              }\n            : img,\n        ),\n      )\n    },\n    [images],\n  )\n\n  const handleRetry = React.useCallback(\n    (id: string) => {\n      handleUpload(id)\n    },\n    [handleUpload],\n  )\n\n  const isUploading = images.some((img) => img.status === 'uploading')\n  const canAddMore = images.length < config.maxFiles\n\n  return (\n    <div className={className}>\n      <div className=\"space-y-4\">\n        {canAddMore && (\n          <DropZone\n            onFilesSelected={handleFilesSelected}\n            disabled={isUploading}\n          />\n        )}\n\n        {errors.length > 0 && (\n          <div className=\"rounded-lg border border-destructive/50 bg-destructive/10 p-4\">\n            <h3 className=\"mb-2 text-sm font-medium text-destructive\">\n              エラーが発生しました\n            </h3>\n            <ul className=\"space-y-1 text-sm text-destructive\">\n              {errors.map((error, index) => (\n                <li key={index}>\n                  {error.file.name}: {error.error.message}\n                </li>\n              ))}\n            </ul>\n            <button\n              type=\"button\"\n              onClick={() => setErrors([])}\n              className=\"mt-2 text-xs text-destructive underline\"\n            >\n              エラーをクリア\n            </button>\n          </div>\n        )}\n\n        {images.length > 0 && (\n          <div>\n            <div className=\"mb-2 flex items-center justify-between\">\n              <p className=\"text-sm text-muted-foreground\">\n                {images.length} / {config.maxFiles} 枚\n              </p>\n              {!autoUpload && (\n                <button\n                  type=\"button\"\n                  onClick={() => {\n                    images.forEach((img) => {\n                      if (img.status === 'idle' || img.status === 'error') {\n                        handleUpload(img.id)\n                      }\n                    })\n                  }}\n                  disabled={isUploading}\n                  className=\"text-sm text-primary hover:underline disabled:opacity-50\"\n                >\n                  すべてアップロード\n                </button>\n              )}\n            </div>\n            <div className=\"grid grid-cols-2 gap-4 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5\">\n              {images.map((image, index) => (\n                <ImagePreview\n                  key={image.id}\n                  image={image}\n                  index={index}\n                  total={images.length}\n                  onRemove={handleRemove}\n                  onMoveUp={handleMoveUp}\n                  onMoveDown={handleMoveDown}\n                  onRetry={handleRetry}\n                />\n              ))}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    }
  ],
  "type": "registry:ui"
}